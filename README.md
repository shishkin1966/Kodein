**Пример реализации Service Locator в Clean Architecture на языке Kotlin**

Архитектура реализует следующие цепочки событий:

источники(view <-> презентер, прочие объекты) -> задание -> провайдер(ы) услуг -> запрос -> исполнитель (специалист/провайдер DB/NET/пр.) -> сообщение с результатом -> мессенджер <-> получатели сообщений(презентеры, прочие объекты)

объекты(запросы) -> изменение Observable объектов(Broadcast, Content Provider, прочих) -> оповещение подписчиков Observable объектов
 
Т.к. начиная с провайдера и заканчивая месенджером объекты не зависят от жизненного цикла View, то на этом участке возможно
использование потоковой обработки событий(реактивного программирования)

Жизненный цикл презентора совпадает с циклом жизни View, к которой он связан. Взаимодействие 
между ними осуществляется через единственный метод интерфеса IActionHandler:

- *addAction(action: iAction)* - добавить Action 

В основе архитектуры лежит модель общественного разделения труда и парадигма функционального программирования. Все объекты делятся на генераторы сервиса и пользователей(потребителей) сервисов. Выделены следующие единицы:
- специалист(интерфейс ISpecialist) - одиночный объект, который предоставляет сервис любым пользователям(объектам) без их учета
- объекты-подписчики (интерфейс ISpecialistSubscriber), которые регистрируются в объединениях для предоставления общего сервиса
- малые объединения подписчиков(интерфейс ISmallUnion) - объект, объединяющий группу подписчиков(ISpecialistSubscriber) для предоставления общего сервиса
- объединения подписчиков(интерфейс IUnion) - объект, объединяющий группу подписчиков(ISpecialistSubscriber) для предоставления расширенной функциональности

Регистрацию подписчиков и их объединений, а также специалистов и их взаимное связывание, отмену регистрации осуществляет сервис локатор (IServiceLocator).
Все объекты учитываемые сервис локатором реализуют интерфейс ISubscriber, включающий в себя интерфейсы IValidated и INamed. Интерфейс INamed, содержит метод:

- *getName(): String* - получить имя объекта.

Интерфейс IValidated определяет следующий метод:

- *isValid(): Boolean* - проверить состояние объекта

Специалист(ISpecialist) - объект, предоставляющий какую-либо функциональность другим объектам.  
Состав интерфейса ISpecialist (наследника INamed и IValidated):
- *isPersistent()*: Boolean – флаг, определяющий тип специалиста - постоянный/выгружаемый - т.е определяет разрешение операции отмены регистрации
- *onUnRegister()* – событие, которое предваряет операцию отмену регистрации 
	специалиста. Используется для внутренних операций в специалисте, необходимых перед отменой 
	регистрации
- *onRegister()* – событие, которое завершает операцию регистрации специалиста
- *stop()* - остановить работу специалиста

Специалисты делятся на постоянные(isPersistent), выгружаемые и короткоживущие. Короткоживущий специалисты
самостоятельно выгружаются из памяти при отсутствии активности потребителей своего сервиса.

Объединение(ISmallUnion или IUnion) подписчиков (классов, реализующие интерфейс ISpecialistSubscriber) учитывает подписчиков только одного типа. Интерфейс ISpecialistSubscriber, является наследником интерфейсов INamed и IValidated и имеет методы:
- *getSpecialistSubscription(): List<String>* – получить список подписки с именами объединений (список имен объединений, в которые он будет входить)
- *onStopSpecialist(specialist: ISpecialist)* - событие - остановлена работа специалиста

Интерфейс ISmallUnion является наследником интерфейса Specialist и имеет методы:
- *createSecretary(): ISecretary<T>* - получить секретаря объединения(объект учитывающий подписчиков)
- *register(subscriber: T): Boolean* – зарегистрировать подписчика
- *unregister(subscriber: T)* – отписать подписчика
- *unregister(name: String)* - отписать подписчика по его имени
- *getSubscribers(): List<T>* - получить список всех подписчиков
- *getValidatedSubscribers(): List<T>* - получить список валидных подписчиков
- *getReadySubscribers(): List<T>* - получить список готовых подписчиков. Т.е. подписчиков, которые поддерживают состояния(IStateable) и находятся в соостянии отличном от CREATE и DESTROY
- *hasSubscribers(): Boolean* - проверить наличие подписчиков
- *hasSubscriber(name: String): Boolean* - проверить наличие подписчика
- *getSubscriber(name: String): T?)* – получить подписчика по его имени.
- *onRegisterFirstSubscriber()* - событие - появился первый подписчик
- *onUnRegisterLastSubscriber()* - событие - отписан последний подписчик
- *onAddSubscriber(subscriber: T)* - событие - добавлен подписчик
- *contains(subscriber: T): Boolean* - проверить наличие подписчика

Наследником интерфейса ISmallUnion является IUnion. Состав методов:
- *getCurrentSubscriber(): T?* - получить текущего подписчика объединения 
- *setCurrentSubscriber(subscriber: T): Boolean* – установить текущего подписчика у объединения

Как было указано, управлением специалистов и объединений занимается администратор, 
реализующий интерфейс IServiceLocator:
- *exists(name: String): Boolean* - Проверить существование специалиста с указанным именем
- *<C : ISpecialist> get(name: String): C?* – получить специалиста/объединение по его имени
- *registerSpecialist(specialist: ISpecialist): Boolean* - зарегистрировать специалиста/объединение. Используется только 
	для Singleton объектов
- *registerSpecialist(name: String): Boolean* – зарегистрировать специалиста/объединение, предварительно создав 
	его. Предпочительный метод.
- *unregisterSpecialist(name: String): Boolean* - отменить регистрацию специалиста/объединения
- *registerSpecialistSubscriber(subscriber: ISpecialistSubscriber): Boolean* – зарегистрировать подписчика объединений
- *unregisterSpecialistSubscriber(subscriber: ISpecialistSubscriber): Boolean* – отменить регистрацию подписчика
- *setCurrentSubscriber(subscriber: ISpecialistSubscriber): Boolean* – сделать подписчика текущим. Администратор сам 
	сделает текущим данного подписчика у всех объединений, на которые подписан объект
- *start()* - старт Service Locator
- *stop()* - остановка Service Locator
- *getSpecialists(): List<ISpecialist>* - получить список специалистов
- *getSpecialistFactory(): ISpecialistFactory* - получить фабрику специалистов

В составе данной реализации описаны следующие специалисты/объединения:
- *ErrorSpecialist(Singleton)* - специалист для регистрации ошибок. Предоставляет функционал регистрации ошибок в ходе работы приложения
- *CrashSpecialist* - специалист, получающий управление при незапланированных прерываниях приложения
- *MessengerUnion* - объединение для учета почтовых клиентов или мессенджер. Обеспечивает хранение и гарантированную доставку сообщений. Сообщения хранятся в объединении и подписчики читают их при переходе в состояние STATE_READY и при подключению к месседжеру. Если получатель сообщения находится в состоянии STATE_READY, то сообщения доставляются сразу же. Возможен контроль сообщений на наличие дубликатов, при этом будут удалятся все предыдущие копии данного сообщения. Поддерживаются списки рассылки. Объединение хранит почтовые сообщения независимо от цикла жизни подписчиков(почта подписчика сохраняется при уничтожении подписчика и доступна при его повторном создании). Возможно добавление сообщений только активным получателям.
- *PresenterUnion* - объединение, регистрирующее презентеры и обеспечивающий доступ к ним. Презентеры могут быть локальными,   т.е. регистрируются только локально или глобальные, ссылку на которые можно получить через данное объединение. 
- *ObservableUnion* - объединение, отвечающее за учет Observable объектов. Поддерживаются Content Provider Observable объекты, Broadcast Observable и слушатели именованных объектов(например таблиц БД). Каждый Observable объект может иметь нескольких слушателей. Старт подписки на событие проводиться при появлении первого слушателя Observable объекта, а отписка - при отмене регистрации последнего слушателя. 
- *CacheSpecialist* - специалист, реализующий кэш Serializable объектов в памяти
- *LocationUnion* - объединение, предоставляющее сервис геолокации
- *NetProvider* - реализация провайдера для выборки данных из сети
- *DbProvider* - реализация провайдера для выборки данных из БД SQLite. Допускается соединение сразу с несколькими БД.
- *UseCasesSpecialist* - короткоживущий специалист, реализующий бизнес логику приложения
- *NotificationSpecialist* - короткоживущий специалист, предоставляющий сервис вывода сообщений в зону уведомлений
- *CommonExecutor* - специалист для выполнения запросов приложения
- *DbExecutor* - специалист для выполнения запросов к БД
- *NetExecutor* - специалист для выполнения запросов по интернету
